{-# OPTIONS_GHC -W #-}
module Build.Interface (load,isValid) where

import qualified Data.ByteString.Lazy as L
import qualified Data.Binary as Binary

import qualified Elm.Internal.Version as Version
import System.Directory (doesFileExist)
import System.Exit
import System.IO

import SourceSyntax.Module

load :: Binary.Binary a => FilePath -> IO a
load filePath =
  do exists <- doesFileExist filePath
     case exists of
       False -> failure $ "Unable to find file " ++ filePath ++ " for deserialization!"
       True -> do
         bytes <- L.readFile filePath
         case Binary.decodeOrFail bytes of
           Right (_, _, binaryInfo) -> return binaryInfo
           Left (_, offset, err) -> failure $ msg offset err

  where
    failure err = do hPutStrLn stderr err
                     exitFailure

    msg offset err = concat
        [ "Error reading build artifact: ", filePath, "\n"
        , "    '", err, "' at offset ", show offset, "\n"
        , "    The file was generated by a previous build and may be outdated or corrupt.\n"
        , "    Please remove the file and try again."
        ]

isValid :: FilePath -> (String, ModuleInterface) -> Either String (String, ModuleInterface)
isValid filePath (name, interface) =
    let version = iVersion interface in
    if version == Version.elmVersion
    then Right (name, interface)
    else Left $ concat
             [ "Error reading build artifact: ", filePath, "\n"
             , "    It was generated by version ", show version, " of the compiler,\n"
             , "    but you are using version ", show Version.elmVersion, "\n"
             , "    Please remove the file and try again.\n"
             ]
